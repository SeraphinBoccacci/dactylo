{"version":3,"file":"static/webpack/static/development/pages/dactylo.js.cf64ea3d755699a152cb.hot-update.js","sources":["webpack:///./containers/train/index.tsx"],"sourcesContent":["import React from \"react\";\nimport {\n  DactyloContainer,\n  DactyloTitle,\n  DactyloLine,\n  DactyloTextContainer,\n  DactyloInput,\n  DactyloWord,\n  DactyloLetter,\n  DactyloHint,\n} from \"./style\";\n\nimport Statistics from \"../../components/statistics\";\n\nimport words from \"../../constants/words\";\nimport { keysMap } from \"../../constants/keys\";\n\nconst numberOfLines = 3;\nconst SPACE = \" \";\n\ninterface wordDetails {\n  word: string;\n  status: string;\n  wordInfo: { letter: string; status: string }[];\n}\n\ninterface dactyloState {\n  displayedWords: wordDetails[][];\n  currentWordId: number;\n  wordValue: string;\n  hint: string | undefined;\n  summary: {\n    okWords: number;\n    wrongWords: number;\n    okLetters: number;\n    wrongLetters: number;\n  };\n}\n\nexport default class Dactylo extends React.Component<any, dactyloState> {\n  constructor(props: any) {\n    super(props);\n\n    const displayedWords: wordDetails[][] = [];\n\n    for (let i = 0; i < numberOfLines; i++) {\n      displayedWords.push(fillLine());\n    }\n\n    this.state = {\n      displayedWords,\n      currentWordId: 0,\n      wordValue: \"\",\n      hint: \"\",\n      summary: {\n        okWords: 0,\n        wrongWords: 0,\n        okLetters: 0,\n        wrongLetters: 0,\n      },\n    };\n  }\n\n  componentDidMount() {\n    this.updateHint();\n  }\n\n  updateLettersStatus = (newValue: string) => {\n    const { displayedWords } = this.state;\n    const [[targetWord]] = displayedWords;\n    const newValueLetters = newValue.split(\"\");\n\n    const updatedWordInfo = targetWord.wordInfo.map((letter, letterIndex) => {\n      if (!newValueLetters[letterIndex]) return { ...letter, status: \"NONE\" };\n      else if (newValueLetters[letterIndex] === letter.letter)\n        return { ...letter, status: \"OK\" };\n      else if (newValueLetters[letterIndex] !== letter.letter)\n        return { ...letter, status: \"WRONG\" };\n      else return { ...letter, status: \"NONE\" };\n    });\n\n    displayedWords[0][0] = {\n      ...targetWord,\n      wordInfo: updatedWordInfo,\n    };\n\n    this.setState({ displayedWords, wordValue: newValue });\n    this.updateHint();\n  };\n\n  goNextWord = () => {\n    const { displayedWords } = this.state;\n    const [firstLine] = displayedWords;\n    const [firstWordOfFirstLine] = firstLine;\n\n    this.updateSummary(firstWordOfFirstLine);\n\n    const updateFirstLine: wordDetails[] = firstLine.slice(1, firstLine.length);\n\n    let updatedDisplayedWords: wordDetails[][] = [\n      updateFirstLine,\n      ...displayedWords.slice(1, 3),\n    ];\n\n    if (!updateFirstLine.length) {\n      updatedDisplayedWords = displayedWords.slice(1, 3);\n      updatedDisplayedWords.push(fillLine());\n    }\n\n    this.setState({\n      displayedWords: updatedDisplayedWords,\n      wordValue: \"\",\n    });\n\n    this.updateHint(true);\n  };\n\n  updateSummary = (doneWord: wordDetails) => {\n    const isWordOk = doneWord.wordInfo.every(({ status }) => status === \"OK\");\n    const wrongLetterCount = doneWord.wordInfo.reduce(\n      (prevCount, { status }) => (status === \"OK\" ? prevCount : prevCount + 1),\n      0\n    );\n    const okLetterCount = doneWord.wordInfo.length - wrongLetterCount;\n\n    this.setState(({ summary }) => ({\n      summary: {\n        okWords: isWordOk ? summary.okWords + 1 : summary.okWords,\n        wrongWords: isWordOk ? summary.wrongWords : summary.wrongWords + 1,\n        okLetters: summary.okLetters + okLetterCount,\n        wrongLetters: summary.wrongLetters + wrongLetterCount,\n      },\n    }));\n  };\n\n  updateHint = (isNextWord?: boolean) => {\n    const { displayedWords } = this.state;\n    const [[targetWord]] = displayedWords;\n    const nextLetter = targetWord.wordInfo.find(\n      ({ status }) => status === \"NONE\"\n    );\n\n    if (isNextWord) {\n      const nextTargetWord = displayedWords[0][1] || displayedWords[1][0];\n      const nextWordFirstLetter = nextTargetWord.wordInfo[0];\n\n      this.setState({ hint: findInMap(nextWordFirstLetter?.letter) });\n    } else {\n      if (nextLetter) {\n        this.setState({ hint: findInMap(nextLetter?.letter) });\n      } else {\n        this.setState({ hint: findInMap(SPACE) });\n      }\n    }\n  };\n\n  handleChange = (e: any) => {\n    const newValue = e.target.value;\n    const newValueLetters = newValue.split(\"\");\n    const newLetter = newValueLetters[newValueLetters.length - 1];\n\n    if (newLetter === SPACE) {\n      this.goNextWord();\n    } else {\n      this.updateLettersStatus(newValue);\n    }\n  };\n\n  render() {\n    const { displayedWords, wordValue, hint, summary } = this.state;\n    const targetWord = displayedWords[0][0];\n\n    return (\n      <DactyloContainer>\n        <Statistics\n          okWords={summary.okWords}\n          wrongWords={summary.wrongWords}\n          okLetters={summary.okLetters}\n          wrongLetters={summary.wrongLetters}\n        ></Statistics>\n        <DactyloTitle>Let's write !</DactyloTitle>\n        <DactyloTextContainer>\n          {displayedWords.map((line, index) => (\n            <DactyloLine key={index}>\n              {line.map(({ wordInfo }, wordIndex) => (\n                <DactyloWord key={wordIndex}>\n                  {wordInfo.map(({ letter, status }, letterIndex) => (\n                    <DactyloLetter key={letterIndex} status={status}>\n                      {letter}\n                    </DactyloLetter>\n                  ))}\n                </DactyloWord>\n              ))}\n            </DactyloLine>\n          ))}\n        </DactyloTextContainer>\n        <DactyloInput\n          id=\"input\"\n          value={wordValue}\n          onChange={this.handleChange}\n          maxLength={targetWord?.word.length}\n          size=\"middle\"\n        ></DactyloInput>\n        <DactyloHint>{hint}</DactyloHint>\n      </DactyloContainer>\n    );\n  }\n}\n\nconst fillLine = () => {\n  const numberOfWords = 10;\n  const line: wordDetails[] = [];\n  for (let i = 0; i < numberOfWords; i++) {\n    const randomIndex: number = Math.ceil(Math.random() * words.length);\n\n    const chosenWord = words[randomIndex].toLowerCase();\n\n    const wordInfo = chosenWord\n      .split(\"\")\n      .map((letter) => ({ letter, status: \"NONE\" }));\n\n    line.push({ wordInfo, word: chosenWord, status: \"NONE\" });\n  }\n\n  return line;\n};\n\nconst findInMap = (letter: string) => {\n  for (let [key, value] of keysMap) {\n    if (key.includes(letter)) return value;\n  }\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAWA;AAEA;AACA;AAEA;AACA;AACA;AAoBA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AA2BA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAFA;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAjDA;AAkDA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AA5EA;AA8EA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AAAA;AAQA;AACA;AA9FA;AA+FA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAnHA;AAqHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AALA;AATA;AAqBA;AACA;;;AACA;AACA;AACA;;;AAuGA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAFA;AAFA;AAeA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;AAvKA;AACA;AADA;AACA;AAyKA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;A","sourceRoot":""}